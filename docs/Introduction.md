# Axon Framework

Axon Framework는 기본적으로 CQRS 패턴과 DDD 개념과, [^1]**이벤트 소싱** 아키텍쳐 패턴을 따른다. 이 3가지 패턴의 조합으로 Axon 기반의 애플리케이션은 도메인 로직 변경에 있어서 더 유연해진다는 장점이 있다.



## Dealing with Complexity

먼저, Axon은 애플리케이션이 점점 더 복잡해지면서 생기는 문제점들에 대해 해결책을 찾으려는 시도에서 만들어졌다. DDD를 적용하면 애플리케이션 복잡성을 해결하는 데 도움이 되지만 여러 개의 production(여기선 마이크로서비스?)가 상호작용하는 구조로 애플리케이션이 돌아가게 된다.

Axon은 도메인 모델과의 상호작용이 어떻게 이루어져야 하는지에 대해 제시한다. 



### DDD & CQRS

DDD는 모델 설게에 많은 중점을 둔 소프트웨어 구축에 대한 접근 방식을 설명한다.

CQRS는 자원 변경 요청인 Command와 자원 조회 요청인 Query를 분리하는 구조를 나타내나.

DDD와 CQRS를 조합한다면, 애플리케이션을 조회 용도와 상태 변경 용도인 컴포넌트로 분리하게 되며, 각 컴포넌트는 각자 고유의 도메인 모델을 가지게 된다. (도메인별로 분리도 됨.) 



아래의 이미지는 Axon 기반의 애플리케이션의 아키텍쳐 구조를 설명한다.

![img](https://gblobscdn.gitbook.com/assets%2F-LOb1hJMvj2flvCj-pr_%2F-LU5wVmzdvJ-6AlTcWD-%2F-LU5wXn73463Z6jsRtcu%2Farchitecture-overview.png?alt=media)



UI 단에서 애플리케이션의 상태를 변경하기 위해 커맨드를 요청한다. 요청된 커맨드는 **Command Handling Component**에게 전달되며, 여기서 command에 대해 검증하고, 어떤 side-effect를 날릴지 결정한다.

command에 의해 발생한 Side-effect는 이벤트를 사용하여 뿌려진다. 그 이벤트는 **Event Handling Components** 가 리스닝하여 핸들링하게 된다. 



### Separation of Business Logic and Infrastructure

우발적인 복잡성이 증가되는 것은 보통 인프라스트럭처와 비즈니스 로직을 섞어서 추상화 하는 것이 원인이 된다. Axon은 이를 최우선 순위로 두고 인프라와 비즈니스 로직 두 가지를 강력히 분리시키도록 하게끔 만들었다. 

일단, Axon은 우발적인 복잡성을 최소화 시키도록 하였다.

* Axon은 Event Sources Aggregate를 구현하기 쉽게 해놨지만, Aggregate를 반드시 Event Sourced로 구현할 필요는 없게끔 한다. Repository 인터페이스가 Event Sourced로의 결정에 대해 추상화를 하였기 때문 (둘다 가능하게끔 만들었다는 소리겠지?)
* Command를 Command Bus를 통해 보내는지 결정하는 컴포넌트는 해당 메시지가 핸들러로 전송되는 방법을 결정하는 데 아무런 책임이 없다.

Axon은 컴포넌트에 대한 인터페이스를 제공함으로서 이를 분리하도록 할 뿐만 아니라, Configuration API의 인프라 선택 사항을 결합하며, 애플리케이션의 인프라 측면과 별도로 비즈니스 로직 컴포넌트 들이 구성된다.



## Explicit Messaging

Axon은 명시적인 메시지 객체 사용을 강력하게 활용한다. 즉, Axon 기반의 애플리케이션의 메시지들은 자바클래스로 표현될 것이다. 이런점에서, 약간 오버헤드가 있을 수는 있지만 몇 가지 장점이 있다.

* 명시적인 메시지 사용은 원격 컴포넌트들에게 보다 쉽고 투명하게 배포할 수있다.
* 명시적인 메시지 사용은 애플리케이션의 장기적인 유지 관리에 중요한 것으로 입증된 메시지 디자인에 중점을 둔다.
* 명시적인 메시지 사용은 후처리를 위해 메시지를 쉽게 저장할 수 있다.

메시징이 Axon의 핵심 개념이긴 하지만, 전체 메시지가 다 그렇게 명시적으로 만들지 않아도 된다. 상황에 따라 명시적으로 만들지 않아도 되긴 한다.

Axon은 메시지를 크게 3가지 카테고리로 분리시킨다.

* Commands: 애플리케이션의 상태를 변경하는 의도로 표현한다. 커맨드는 한 방향으로 라우팅되고 응답을 제공할 것이다.
* Queries: 정보를 얻기 위한 목적으로 표현한다. Dispatch 전략에 의존하며, 쿼리는 여러 방향으로 동시에 라우팅될 수 있다.
* Events: 관련된 일이 발생했다는 알림을 나타낸다. 이벤트는 관심있는 모든 구성요소에 전파되며, 어떤 형태의 반환값도 제공하지 않는다.



## Location transparency

명시적인 메시지를 사용하는데 있어서 가장 큰 이점은 각각 다른 컴포넌트와 상호작용하는 컴포넌트는 그 상대방의 위치를 알 필요가 없다는 점이다. 즉, 송신 컴포넌트는 메시지가 어디로 도착했는지 몰라도 된다는 것이다. 이런 특징을 Location Transparency라고 부른다.

Axon은 논리적 URL 뒤에 서비스를 배치하는 것 보다 Location transparency를 더 중요시 여긴다. Axon에서 송신 컴포넌트는 메시지의 도착 지점을 알 필요가 없다. 메시지들은 메시지의 스테레오 타입(Command, Query, Event)과 전달하는 Payload 타입에 기반하여 라우팅된다. 



## Event Sourcing

이벤트는 어떤 값을 가진다. 커맨드나 쿼리 값이 side-effect를 유발하거나 결과를 제공했을 때 크게 감소하는 경우, 이벤트는 발생한 일을 나타내므로 이벤트 발생 후 오랫동안 알아내면 유용할 것이다.

이벤트는 추적을 위한 고수준의 세분화를 제공한다. 하지만, 추적이 100% 신뢰도가 되려면 사이드이펙트 뿐 아니라 모든 결정이 추적에 올바르게 반영되도록 보장할 수 있어야 한다.

이벤트 소싱은 이벤트가 커맨드의 사이드이펙트를 발생시킬 뿐 아니라 상태의 근원을 형성하는 과정이다. 애플리케이션의 현재 상태가 명시적으로 DB에 저장되지 않는 반면, 현재의 상태를 도출하는 데 사용할 수 있는 일련의 이벤트로 암시적으로 저장된다. 커맨드 수신자에서는 애플리케이션의 상태가 DB에 저장된 이벤트로부터 동적으로 파생된 다음 적용할 사이드이펙트를 결정한다.

이벤트 소싱은 구조가 아주 복잡한데, Axon은 이벤트 소싱을 쉽게 구성하고 커맨드 모델을 쉽게 만들  수 있도록 하는 API를 제공해준다. 























### 각주

[^1]: 도메인 모델에서 발생하는 모든 이벤트를 기록하는 데이터 저장 기법

